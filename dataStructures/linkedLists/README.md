## About

**Связный список** - это структура данных, в которой несколько значений хранятся линейно.

Каждое значение содержит своё собственное значение узла, а также содержит данные вместе со ссылкой на следующий узел в списке.

**Ссылка-Узел-LinkedListNode** - это указатель на другой объект узла или на null, если следующего узла нет. Если у каждого узла есть только один указатель на другой узел (чаще всего называется next), то этот список считается односвязный (**singly linked list**); тогда как если у каждого узла есть две ссылки (обычно previous и next), то он считается двусвязный (**doubly linked list**).

Узел имеет две части информации:

- Указатель или ссылка на следующий узел в списке next (для односвязного списка).
- Значение узла value.

Также, он будет содержать один метод - toString: который возвращает значение в строке.

список узлов будет содержать десять методов:

- prepend(значение): принимает значение и создаёт новый узел с этим значением, помещая его в начало связного списка;
- append(значение): принимает значение и создаёт новый узел с этим значением, помещая его в конец связного списка;
- delete(значение): принимает значение и удаляет все узлы, которые имеют указаное значение;
- find(значение): принимает значение и находит первый узел с таким же значением;
- deleteTail(): удаляет последний узел из списка;
- deleteHead(): удаляет первый узел из списка;
- fromArray(массив значений): принимает массив значений и создаёт новые узлы из каждого элемента массива, добавляя их в конец списка;
- toArray(): создаёт массив из всех узлов;
- toString(обратный вызов): принимает обратный вызов (не обязательно) и создаёт строку из всех значений узлов;
- reverse(): создаёт обратный список, меняя узлы местами.

## Why list

Массивы обычно хранятся в едином блоке памяти, что позволяет использовать для индексации быструю формулу start_of_array_in_memory + space_allocated_for_each_array_item \* index_of_item_we_want.
Это очень эффективно, когда вам нужно получить объект с определённым индексом. Однако при удалении или добавлении элементов эффективность алгоритма падает, ведь придётся перемещать все данные в другой блок памяти. Для массивов требовалось резервировать необходимый обьем памяти под элементы и можно было легко исчерпать доступную память или наоборот, не использовать то, что было зарезервировано. Связные списки были созданы, чтобы обойти эту проблему.

Встроенный тип JavaScript Array не реализован как связный список, хотя его размер динамический и всегда является лучшим вариантом для начала.

В отличие от массивов, связные списки не требуют хранения данных в одном непрерывном блоке памяти. Это облегчает добавление элементов в начало списка и их удаление. Указатели содержат ссылку на любую ячейку памяти, и для добавления нового узла не нужно перемещать массу данных.

Поиск по связному списку, добавление объекта в середину и удаление такой записи гораздо менее эффективны. Нам пришлось бы пройти от головного узла весь путь к тому, который нам нужен.

Ещё один недостаток связных списков заключается в том, что они требуют чуть больше памяти, так как помимо данных хранят ещё и указатели.
